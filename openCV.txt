*Instalation de la bibliothèque:
pip install opencv-python mediapipe numpy pyserial


*code pour le OpenCV:
import cv2, mediapipe as mp, serial, numpy as np

# Initialisation
mp_hands = mp.solutions.hands
hands = mp_hands.Hands(min_detection_confidence=0.8)
arduino = serial.Serial('COM3', 9600)  # Changez COM3 si nécessaire

cap = cv2.VideoCapture(0)  # Utilise la caméra du PC

while True:
    success, img = cap.read()
    if not success: continue
    
    img = cv2.flip(img, 1)  # Miroir
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    results = hands.process(img_rgb)
    
    if results.multi_hand_landmarks:
        for hand in results.multi_hand_landmarks:
            # Points des doigts (extrémités)
            fingers = [4, 8, 12, 16, 20]  # Pouce, Index, Majeur, Annulaire, Auriculaire
            angles = []
            
            for fid in fingers:
                y = hand.landmark[fid].y
                angle = int(np.interp(y, [0.2, 0.8], [0, 180]))  # Conversion en angle
                angles.append(angle)
            
            # Envoi à l'Arduino (ex: "90,45,120,30,180")
            arduino.write(f"{','.join(map(str, angles))}\n".encode())
            
            # Dessiner les landmarks (optionnel)
            mp.solutions.drawing_utils.draw_landmarks(img, hand, mp_hands.HAND_CONNECTIONS)
    
    cv2.imshow("Contrôle IA", img)
    if cv2.waitKey(1) == ord('q'): break

cap.release()
cv2.destroyAllWindows()





////////////////////////////////////////////////////
# Détection Optimisée avec la caméra 
import cv2
import mediapipe as mp
import numpy as np
import serial
from collections import deque

# Configuration
ARDUINO_PORT = 'COM3'  # Port série (vérifiez dans le Gestionnaire de périphériques)
CAMERA_INDEX = 0       # 0 pour la caméra intégrée
SMOOTHING_WINDOW = 5   # Nombre de frames pour lisser les mouvements

# Initialisation
mp_hands = mp.solutions.hands
hands = mp_hands.Hands(
    static_image_mode=False,
    max_num_hands=1,
    min_detection_confidence=0.7,
    min_tracking_confidence=0.7
)
arduino = serial.Serial(ARDUINO_PORT, 9600, timeout=1)
cap = cv2.VideoCapture(CAMERA_INDEX)
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)  # Réduire la résolution pour la fluidité
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
angle_history = deque(maxlen=SMOOTHING_WINDOW)

while cap.isOpened():
    success, img = cap.read()
    if not success:
        continue
    
    img = cv2.flip(img, 1)  # Effet miroir
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    results = hands.process(img_rgb)
    
    if results.multi_hand_landmarks:
        landmarks = results.multi_hand_landmarks[0]
        fingers = [4, 8, 12, 16, 20]  # Landmarks des bouts des doigts
        angles = []
        
        for fid in fingers:
            y = landmarks.landmark[fid].y
            angle = int(np.interp(y, [0.2, 0.8], [0, 180]))  # Calibration
            angles.append(angle)
        
        angle_history.append(angles)
        smoothed_angles = np.mean(angle_history, axis=0).astype(int)
        arduino.write(f"{','.join(map(str, smoothed_angles))}\n".encode())
        
        # Dessiner les landmarks (optionnel)
        mp.solutions.drawing_utils.draw_landmarks(img, landmarks, mp_hands.HAND_CONNECTIONS)
    
    cv2.imshow("Contrôle Main Robotique", img)
    if cv2.waitKey(1) == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
arduino.close()